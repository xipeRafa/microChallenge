<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS FUNCTIONAL</title>
</head>

<style>

    body{
        font-family: sans-serif;
        background-color: rgb(26, 17, 66);
        color: cornsilk;
        padding-left: 40px;
    }

    pre{
        background-color:rgb(215, 230, 250);
        color:rgba(0, 0, 0, 0.521);
        display: none;
        padding-right: 40px;
        margin-left: 40px;
    }

    p{
        user-select: none; 
        padding-left: 20px; 
    }

    a{
        text-decoration: none;
    }

    .display{
        display: inline-block;
    }

</style>
<script>
     
    function toggle(){
        document.querySelector("#pre").classList.toggle("display");
        document.querySelector("#pre2").classList.toggle("display");
    }
    
    function toggle2(){
        document.querySelector("#pre4").classList.toggle("display");
        document.querySelector("#pre4a").classList.toggle("display");
        document.querySelector("#pre4b").classList.toggle("display");
    }
    
    function toggle3(){
        document.querySelector("#pre5").classList.toggle("display");
        document.querySelector("#pre5a").classList.toggle("display");
        document.querySelector("#pre6a").classList.toggle("display");
    }
    
       
    function toggle4(){
        document.querySelector("#pre7").classList.toggle("display");
        document.querySelector("#pre7a").classList.toggle("display");
    }

    function toggle5(){
        document.querySelector("#pre8").classList.toggle("display");
        document.querySelector("#pre8a").classList.toggle("display");
        document.querySelector("#pre8b").classList.toggle("display");
    }

    function toggle55(){
        document.querySelector("#pre88").classList.toggle("display");
        document.querySelector("#pre8aa").classList.toggle("display");
        document.querySelector("#pre8bb").classList.toggle("display");
    }
    
    function toggle5a(){
        document.querySelector("#pre15aa").classList.toggle("display");
        document.querySelector("#pre15bb").classList.toggle("display");
        document.querySelector("#pre15cc").classList.toggle("display");
    }

    function toggle6(){
        document.querySelector("#pre9").classList.toggle("display");
    }

    function toggle7(){
        document.querySelector("#pre10").classList.toggle("display");
        document.querySelector("#pre10a").classList.toggle("display");
    }

    function toggle8(){
        document.querySelector("#pre11").classList.toggle("display");
    }

    function toggle9(){
        document.querySelector("#pre12").classList.toggle("display");
    }

    function toggle11(){
        document.querySelector("#pre14").classList.toggle("display");
        document.querySelector("#pre14a").classList.toggle("display");
        document.querySelector("#pre14b").classList.toggle("display");
        document.querySelector("#pre14c").classList.toggle("display");
    }

    function toggle13(){
        document.querySelector("#pre16").classList.toggle("display");
    }

    function toggle14(){
        document.querySelector("#pre17").classList.toggle("display");
        document.querySelector("#pre17a").classList.toggle("display");
        document.querySelector("#pre17b").classList.toggle("display");
    }

    function toggle15(){
        document.querySelector("#pre18").classList.toggle("display");
        document.querySelector("#pre18a").classList.toggle("display");
    }

    function toggle16(){
        document.querySelector("#pre19").classList.toggle("display");
        document.querySelector("#pre19a").classList.toggle("display");
    }

    function toggle17(){
        document.querySelector("#pre20").classList.toggle("display");
        document.querySelector("#pre20a").classList.toggle("display");
    }
     
    function toggle18(){
        document.querySelector("#pre21").classList.toggle("display");
        document.querySelector("#pre21a").classList.toggle("display");
    }

    function toggle19(){
        document.querySelector("#pre22").classList.toggle("display");
        document.querySelector("#pre22a").classList.toggle("display");
    }

    function toggle20(){
        document.querySelector("#pre23").classList.toggle("display");
        document.querySelector("#pre23a").classList.toggle("display");
    }

    function toggle21(){
        document.querySelector("#pre24").classList.toggle("display");
        document.querySelector("#pre24a").classList.toggle("display");
    }

    function toggle22(){
        document.querySelector("#pre25").classList.toggle("display");
        document.querySelector("#pre25a").classList.toggle("display");
    }

    function toggle23(){
        document.querySelector("#pre26").classList.toggle("display");
        document.querySelector("#pre26a").classList.toggle("display");
    }

    function toggle24(){
        document.querySelector("#pre27").classList.toggle("display");
        document.querySelector("#pre27a").classList.toggle("display");
    }

    function toggle25(){
        document.querySelector("#pre28").classList.toggle("display");
        document.querySelector("#pre28a").classList.toggle("display");
    }

    function toggle26(){
        document.querySelector("#pre29").classList.toggle("display");
    }

  


</script>
<body>

    <h1>FUNCTIONAL PROGRAMING</h1>

    <div>  <!-- Introduction -->
        <p onclick="toggle()">Introduction to Functional Programming</p>

        <pre id="pre">

            This is how most of us were taught to program by default (imperatively):

            const numbers = [1, 2, 3, 4];
            let doubled = [];

            for(let i=0; i < numbers.length; i++){
                doubled.push(numbers[i]*2);
            }

            console.log(doubled) 
            
            Output
            
            [2, 4, 6, 8]
        </pre>
        <pre id="pre2">

            This is how it would be done declaratively (using functional programming):
          
            const numbers = [1, 2, 3, 4];
            const doubled = numbers.map(n => n*2);

            console.log(doubled) 
            
            Output
            
            [2, 4, 6, 8];
        </pre>
    </div>  
    <div>  <!-- JavaScript tools -->
        <p onclick="toggle2()">JavaScript tools</p>

        <pre id="pre4">

            - Immutability
            - Use pure functions.
            - Use of higher order functions.
            - Use of currying.
            - Composition of functions.
        </pre>   
        <pre id="pre4a">

            map: Result preserves the shape of the input argument, probably with a different type.

            filter: The result will have the same shape as the input argument, probably shorter.

            reduce: The result can be completely transformed.


            [1, 2, 3].map(n => n+1);      // => [2, 3, 4]
            
            [1, 2, 3].filter(n => n>1);   // => [2, 3]
            
            [1, 2, 3].reduce((acc, n) => acc + n, 0);
            // 0 + 1 => 1
            // 1 + 2 => 3
            // 3 + 3 => 6
            // => 6  
        </pre>
        <pre id="pre4b">

            Higher-order functions are those that take one or more functions as
            an argument or return functions as a result. They interest us 
            because they allow us to reuse the way we execute other functions.

            the map function is defined to receive a function with the 
            signature function (currentValue, index, array)

            const result = ["1", "2", "3"].map((item) => parseInt(item));
            console.log(result);
        </pre> 
    </div>  
    <div>  <!-- map -->
        <p onclick="toggle3()">map</p>
        <pre id="pre5">

            const array1 = [1, 4, 9, 16];

            const map1 = array1.map((element, index, array) => {
                    console.log('index:', index, 'element:', element, 'array1:', array);
                    
            });

            Output

            > "index:" 0 "element:" 1 "array1:" Array [1, 4, 9, 16]
            > "index:" 1 "element:" 4 "array1:" Array [1, 4, 9, 16]
            > "index:" 2 "element:" 9 "array1:" Array [1, 4, 9, 16]
            > "index:" 3 "element:" 16 "array1:" Array [1, 4, 9, 16]

            <hr>

            const objects = [{id:'1', name:'aaa', price: 100},
                             {id:'2', name:'bbb', price: 200},
                             {id:'3', name:'ccc', price: 300}]

            const idObject = objects.map(object => object.id)

            console.log('ids:', idObject)

            

            // or you can use:

            const idObject2 = objects.map( ({id}) => id ) 
            
            console.log('ids2:', idObject2) 

        </pre>

        <pre id="pre5a">

              function returnInt(element) {
                return parseInt(element, 10)
              }
              
              ['1', '2', '3'].map(returnInt); // [1, 2, 3]
              // Actual result is an array of numbers (as expected)
              
              // Same as above, but using the concise arrow function syntax
              ['1', '2', '3'].map( str => parseInt(str) )
              
              // A simpler way to achieve the above, while avoiding the "gotcha":
              ['1', '2', '3'].map(Number)  // [1, 2, 3]
              
              // But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:
              ['1.1', '2.2e2', '3e300'].map(Number)  // [1.1, 220, 3e+300]
              
              // For comparison, if we use parseInt() on the array above:
              ['1.1', '2.2e2', '3e300'].map( str => parseInt(str) ) // [1, 2, 3]
        </pre>
        <pre id="pre6a">
           
            When not to use map()

            Since map builds a new array, using it when you aren't using the returned 
            array is an anti-pattern; use forEach or for...of instead.

            You shouldn't be using map if:

            you're not using the array it returns; and/or
            you're not returning a value from the callback.

            map does not mutate the array on which it is called 
            (although callbackFn, if invoked, may do so).

            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"
             target="_blank">see the docs →</a>
        </pre>    
    </div> 
    <div>  <!-- filter -->
        <p onclick="toggle4()">filter</p>

        <pre id="pre7">

        const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

            const result = words.filter(word => word.length > 6);
            console.log(result);

            output: 
            Array ["exuberant", "destruction", "present"]

            <hr>

            const result2 = words.filter((word, index) => {
                console.log(index, word)
            })

            output:
            > 0 "spray"
            > 1 "limit"
            > 2 "elite"
            > 3 "exuberant"
            > 4 "destruction"
            > 5 "present"

            <hr>

            const objects = [{id:'1', name:'aaa', price: 100},
                             {id:'2', name:'bbb', price: 200},
                             {id:'3', name:'ccc', price: 300}]

            const lowCost = object => object.price < 201
           const highCost = object => !lowCost(object)                  

            const lowCostObjects = objects.filter(lowCost)
           const highCostObjects = objects.filter(highCost)

           console.log(lowCostObjects)
           console.log(highCostObjects)

           <hr>

           Remove repeating items:

           const array2 = [5, 22, 11, 5, 4, 5, 5, 1];

           const array2X = array2.filter((el, place, array2) => {
               return place === array2.indexOf(el)
           })

           console.log(array2X)

           
        </pre>
        <pre id="pre7a">

        Filtering out all small values

            const isBigEnough = value => value >= 10;
            let arr = [12, 5, 8, 130, 44]
            let filtered = arr.filter(isBigEnough);

            console.log(filtered)

            Output
            > Array [12, 130, 44]

        let words = ['spray', 'limit', 'exuberant', 'destruction','elite', 'present']

            const modifiedWords = words.filter( (word, index, arr) => {
                 return word[index+2]  //delete the last 2 items
            })
            console.log(modifiedWords)  
            
            Output
            > Array ["spray", "limit", "exuberant", "destruction"]

            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#examples"
            target="_blank">see the docs →</a>
        </pre>
       
    </div>  
    <div> <!-- reduce -->
        <p onclick="toggle5()">reduce</p>
        <pre id="pre8">
  
            const array1 = [1, 2, 3, 4];
            const reducer = (accumulator, currentValue) => accumulator + currentValue;
            
            // 1 + 2 + 3 + 4
            console.log(array1.reduce(reducer));
            output: 10
            
            // 1 + 2 + 3 + 4 + 5
            console.log(array1.reduce(reducer, 5));
            output: 15

            <hr>
            let total = [ 0, 1, 2, 3 ].reduce(
              ( accumulator, currentValue ) => accumulator + currentValue, 1
            )
            console.log(total)
            output: 7
        </pre>
        <pre id="pre8a">

            Sum of values in an object array

            let initialValue = 0
            let sum = [{x: 1}, {x: 2}, {x: 3}]
            let sumReduce = sum.reduce((accumulator, currentValue, position, sum) => accumulator + currentValue.x, initialValue)
          
            console.log(sumReduce) 
            console.log(sum) 

            output: 6

            <hr>
          
            const nums = [11, 22, 33, 44, 55, 66, 77];

            const x2 = (accumulator, num) => [...accumulator, num * 2]
             
            const double = nums.length > 0 ? nums.reduce(x2, []) : 0;

            console.log('double:', double)
            console.log('nums:', nums) // no mutation in the original array



        </pre>
        <pre id="pre8b">

            Remove duplicate items in an array (reduce)

            let myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']
            let myArrayWithNoDuplicates = myArray.reduce(function (accumulator, currentValue) {
              if (accumulator.indexOf(currentValue) === -1) {
                accumulator.push(currentValue)
              }
              return accumulator
            }, [])

            console.log(myArrayWithNoDuplicates)

            output: Array ["a", "b", "c", "e", "d"]
            
            <hr>
            or:
            let array = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']
            let arrayWithNoDuplicates = Array.from(new Set(array))
            console.log(arrayWithNoDuplicates)

            output: Array ["a", "b", "c", "e", "d"]
        </pre>
    </div>
    <div> <!-- Mix high order functions -->
        <p onclick="toggle55()">Mix high order functions</p>
        <pre id="pre88">
  
            const array1 = [1, 2, 3, 4];
            const reducer = (accumulator, currentValue) => accumulator + currentValue;
            
            // 1 + 2 + 3 + 4
            console.log(array1.reduce(reducer));
            output: 10
            
            // 1 + 2 + 3 + 4 + 5
            console.log(array1.reduce(reducer, 5));
            output: 15

            <hr>
            let total = [ 0, 1, 2, 3 ].reduce(
              ( accumulator, currentValue ) => accumulator + currentValue, 1
            )
            console.log(total)
            output: 7
        </pre>
        <pre id="pre8aa">

            Sum of values in an object array

            let initialValue = 0
            let sum = [{x: 1}, {x: 2}, {x: 3}]
            let sumReduce = sum.reduce((accumulator, currentValue, position, sum) => accumulator + currentValue.x, initialValue)
          
            console.log(sumReduce) 
            console.log(sum) 

            output: 6

            <hr>
          
            const nums = [11, 22, 33, 44, 55, 66, 77];

            const x2 = (accumulator, num) => [...accumulator, num * 2]
             
            const double = nums.length > 0 ? nums.reduce(x2, []) : 0;

            console.log('double:', double)
            console.log('nums:', nums) // no mutation in the original array



        </pre>
        <pre id="pre8bb">

            Remove duplicate items in an array (reduce)

            let myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']
            let myArrayWithNoDuplicates = myArray.reduce(function (accumulator, currentValue) {
              if (accumulator.indexOf(currentValue) === -1) {
                accumulator.push(currentValue)
              }
              return accumulator
            }, [])

            console.log(myArrayWithNoDuplicates)

            output: Array ["a", "b", "c", "e", "d"]
            
            <hr>
            or:
            let array = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']
            let arrayWithNoDuplicates = Array.from(new Set(array))
            console.log(arrayWithNoDuplicates)

            output: Array ["a", "b", "c", "e", "d"]
        </pre>
    </div>


    <br/>
    <div> <!-- forEach -->
        <p onclick="toggle5a()">forEach</p>
        <pre id="pre15aa">

         forEach()

         Essentially the non-pure version of map(), forEach() iterates over an array and
         applies a callback() function over each item. However, it doesn’t return anything.
         It’s a cleaner way of performing a for loop.
         
         <hr>

        for ([expresion-inicial]; [condicion]; [expresion-final])sentencia

                let arr = [1,2,3,4,5]; 
                
                for(i=0; i < arr.length; i++){
                    console.log(arr[i])
                }

            <hr>

            const array1 = ['a', 'b', 'c'];

            array1.forEach(element => console.log(element));

             output:

                     "a"
                     "b"
                     "c"
        </pre>
        <pre id="pre15bb">

        FOR IN    
          
            const object = {
                name: 'rene',
                age: 22,
                country: 'USA'
            }
              
              for (const property in object) {
                 console.log(`key: ${property}, value: ${object[property]}`)
              }

              > "key: name, value: rene"
              > "key: age, value: 22"
              > "key: country, value: USA"

              // for in is just to objects
        </pre>
        <pre id="pre15cc">

        FOR OF

                let iterable = [10, 20, 30];

                for (let value of iterable) {
                  value += 1;
                  console.log(value);
                }

                Output

                // 11
                // 21
                // 31

                <a href="https://developer.mozilla.org/es/docs/orphaned/Web/JavaScript/Reference/Statements/for...of" target="_blank">see docs →</a>
        </pre>
    </div>  
    <div> <!-- composicion -->
        <p onclick="toggle9()"> Composicion </p>
        <pre id="pre12">
 

          const original = [80, 3, 14, 22, 30];

            let aux = original.filter((value) => value%2 === 0);
            aux = aux.filter((value) => value > 20);
            const result = aux.reduce((accumulator, value) => accumulator + value);

            console.log(result); // 132
       
            <hr>
           
    If we pull ES6 we can apply the chain pattern:

          const original = [80, 3, 14, 22, 30];

            const result = original
                .filter((value) => value%2 === 0)
                .filter((value) => value > 20)
                .reduce((accumulator, value) => accumulator + value);

            console.log(result); // 132 

            <hr>

    Wrap this in functions:

          const original = [80, 3, 14, 22, 30];

            const filterOnlyPairElements = (values) => values.filter((value) => value%2 === 0);
            const filterGreaterThan = (values) => (max) => values.filter((value) => value > max);
            const sumAllValues = (values) => values.reduce((accumulator, value) => accumulator + value);
            
            const result = sumAllValues(
                filterGreaterThan(
                    filterOnlyPairElements(original)
                )(20)
            );
            
            console.log(result); // 132   

            <hr>
            
    This makes this code unreadable, Ramda to the rescue.

        We are going to use Pipe this function allows us to chain functions,
        the output of one serves as input for the other.   
        
          const original = [80, 3, 14, 22, 30];

            const result = R.pipe(
              R.filter((value) => value%2 === 0),
              R.filter((value) => value > 20),  
              R.sum,
            )(original);
        
            console.log(result); // 132

            <hr>
        
    And why do we use things like R.filter and R.sum instead of what ES6 brings for arrays?

          const original = [80, 3, 14, 22, 30];

            const filterOnlyPairElements = (values) => R.filter((value) => value%2 === 0, values);
            const filterGreaterThan = R.curry((max,values) => R.filter((value) => value > max, values));
            const sumAllValues = (values) => R.sum(values);

            const result = R.pipe(
              filterOnlyPairElements,
              filterGreaterThan(20),  
              sumAllValues,
            )(original);

            console.log(result); // 132

        <hr>
        
    we can use the filter and reduce from ES6, being as follows:

        const original = [80, 3, 14, 22, 30];

        const filterOnlyPairElements = (values) => values.filter((value) => value%2 === 0);
        const filterGreaterThan = R.curry((max,values) => values.filter((value) => value > max));
        // Or const filterGreaterThan = (max) => (values) => values.filter((value) => value > max);
        const sumAllValues = (values) => values.reduce((accumulator, value) => accumulator + value);
        
        const result = R.pipe(
          filterOnlyPairElements,
          filterGreaterThan(20),  
          sumAllValues,
        )(original);
        
        console.log(result); // 132

        <hr>

    The pipe function allows us to pass as many callbacks and input parameters as we want such that:

        const result = R.pipe(
            callback1,
            callback2,
            callback3,
            callback4,
            ...
            )(param1, param2, ...);

            <hr>

    But even so, if we don't want to install Ramda or lodash and we want 
    to get the same result applied to the previous array, we could do something like:

        const original = [80, 3, 14, 22, 30];

        const filterOnlyPairElements = (values) => values.filter((value) => value%2 === 0);
        const filterGreaterThan = (max) => (values) => values.filter((value) => value > max);
        const sumAllValues = (values) => values.reduce((accumulator, value) => accumulator + value);
        
        const pipe = (...callbacks) => (array) => (
          callbacks.reduce((previous, callback) => (
            callback(previous)
          ), array)
        );
        
        const result = pipe(
          filterOnlyPairElements,
          filterGreaterThan(20),
          sumAllValues,
        )(original);
        
        console.log(result); // 132
        </pre>
    </div>
    <div> <!-- closures -->
        <p onclick="toggle7()">Closures</p>
        <pre id="pre10">
          
            
            function error(str) {
                console.log(`%c Error: ${str} `, 'background: red; color: white;');
              }
              
            function warning(str) {
                console.log(`%c Warning: ${str} `, 'background: orange; color: white;');
              }
              
            function success(str) {
                console.log(`%c success: ${str} `, 'background: green; color: white;');
              }

              error('error text')
              warning('warning text')
              success('success text')  
        </pre>
        <pre id="pre10a">

            closure:

            function messages(typeM, styles) {
                return function message(str) {
                  console.log(`%c ${typeM}: ${str} `, styles);
                }
              }
              
              const error = messages('Error', 'background: red;');
              const warning = messages('Warning', 'background: orange;');
              const success = messages('Success', 'background: green;');
              
              error('error text')
              warning('warning text')
              success('success text')
        </pre>
    </div>  
    <div> <!-- currying -->
        <p onclick="toggle8()">Currying</p>
        <pre id="pre11">
 
            
            const sum = (a, b) => {
                return a + b
            }

            sum(2, 2)
             
            <hr>

            const sumCurrying = (a) => {
                return (b) => {
                return a + b
              }
            }

            const res = sumCurrying(1)(2)
            console.log(res)

            <hr>

            const sumCurryingS = (a) => (b) => (c) => a + b + c;

            sumCurryingS(1)(2)(3)

            <hr>

            const sumCurrying= (a) => (b) => a + b;

            const increment10 = sumCurrying(10)

            const res = increment10(20)
            
            console.log(res)

            Output
            30

        </pre>
    </div>  
    <div> <!-- Generator -->
        <p onclick="toggle11()">Generator </p>
        <pre id="pre14">

        convert the code of a function into iterable code

            function* iterable(){

                yield 'hello 1';
                console.log('hello from log')
                yield 'hello 2';
                yield 'hello 3';
                console.log('hello again from log')
                yield 'hello 4';
                yield 'hello 5';
            }
             
            let iterador = iterable()

                console.log(iterador.next());
                console.log(iterador.next());
                console.log(iterador.next());
                console.log(iterador.next());
                console.log(iterador.next());

                console.log(iterador.next());   //undefined done:true (true. is the end )
                console.log(iterador.return(1)) // {value: 1, done: true}

                Output

                {value: "hello 1", done: false}
                hello from log
                {value: "hello 2", done: false}
                {value: "hello 3", done: false}
                hello again from log
                {value: "hello 4", done: false}
                {value: "hello 5", done: false}
                {value: undefined, done: true}
                {value: 1, done: true}
        </pre>
        <pre id="pre14a">
            
            function* iterable(){

                yield 'hello 1';
                console.log('hello from log')
                yield 'hello 2';
                yield 'hello 3';
                console.log('hello again from log')
                yield 'hello 4';
                yield 'hello 5';
            }
             
            let iterator = iterable()

            for(let y of iterator){
                console.log(y)
            }
        </pre>
        <pre id="pre14b">

            function* iterable(){

                yield 'hello 1';
                console.log('hello from log')
                yield 'hello 2';
                yield 'hello 3';
                console.log('hello again from log')
                yield 'hello 4';
                yield 'hello 5';
            }

            let arr = [...iterable()]
            console.log(arr)

            Output

            hello from log
            hello again from log
            ["hello 1", "hello 2", "hello 3", "hello 4", "hello 5"]
        </pre>
        <pre id="pre14c">

            function* gen() {
                while(true) {
                  try {
                     yield 42;
                  } catch(e) {
                    console.log('Error caught!');
                  }
                }
              }
              
              let g = gen();
              g.next();
              // { value: 42, done: false }
              g.throw(new Error('Something went wrong'));
              // "Error caught!"
              // { value: 42, done: false }
              
        </pre>
    </div>   
    <div> <!-- IFEE -->
        <p onclick="toggle13()">IFEE</p>
        <pre id="pre16">

            An IIFE (Immediately Invoked Function Expression)
            This prevents accessing letiables within the IIFE idiom 
            as well as polluting the global scope.

            (function () {
                statements
              })();
        </pre>
    </div> 
    <div> <!-- Array.from() -->
        <p onclick="toggle14()">Array.from()</p>
        <pre id="pre17">
          
            console.log(Array.from('foo')); 
            
            output:
            Array ["f", "o", "o"]

            console.log(Array.from([1, 2, 3], x => x + 1)); 
            
            output:
            Array [2, 4, 6]

            let arr = 'hello'
            Array.from(arr, (element, index) => { 
                 console.log('index:', index, element + ' -') 
            })
            
            index: 0 h -
            index: 1 e -
            index: 2 l -
            index: 3 l -
            index: 4 o -
        </pre>
        <pre id="pre17a">

            Array from a Map
            const map = new Map([[1, 2], [2, 4], [4, 8]]);
            Array.from(map);
            // [[1, 2], [2, 4], [4, 8]]
            
            const mapper = new Map([['1', 'a'], ['2', 'b']]);
            Array.from(mapper.values());
            // ['a', 'b'];
            
            Array.from(mapper.keys());
            // ['1', '2'];

            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from"
            target="_blank">see the docs →</a>
        </pre>
        <pre id="pre17b">

            Sequence generator (range)

            // Sequence generator function (commonly referred to as "range", e.g. Clojure, PHP etc)
            const range = (start, stop, step) => Array.from({
                 length: (stop - start) / step + 1
            }, (_, i) => start + (i * step));

            // Generate numbers range 0..4
            range(0, 4, 1);
            // [0, 1, 2, 3, 4]

            // Generate numbers range 1..10 with step of 2
            range(1, 10, 2);
            // [1, 3, 5, 7, 9]

            // Generate the alphabet using Array.from making use of it being ordered as a sequence
            range('A'.charCodeAt(0), 'Z'.charCodeAt(0), 1).map(x => String.fromCharCode(x));
            // ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", 
            "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

        </pre>
    </div>   
    <div> <!-- REST Parameters-->
        <p onclick="toggle15()">REST Parameters</p>
        <pre id="pre18">

            RECEIVE UNLIMITED PARAMETERS IN A FUNCTION

            function separarConComa1() {
                let resultado = ''
                for (let i = 0; i < arguments.length; i++) {
                  if (resultado !== '') {
                    resultado += ' + ';
                  }
                  resultado += arguments[i];
                }
                return resultado;
              }
              separarConComa1('MEME', 'MEME', 'MEME')

              NOTE: YOU CAN NOT USE ARGUMENTS(object) IN A AROW FUNCTION
        </pre>
        <pre id="pre18a">


            const separador = (...strings) => {
                let res = '';
                    for(i=0; i < strings.length; i++){
                        if(res !== ' '){
                            res += ' + '
                        }
                    res += strings[i]
                }
                return res
            }

            separador('ff','ee','dd')

            <hr>

            const separarCon = (separator, ...strings) => 
                strings.reduce((resultado, str) => {

                if (resultado !== '') {
                  resultado += separator
                };
              
                return resultado + str;
            }, '');
              
            console.log(separarCon(' + ', 'Pablo', 'Laura', 'Juan'));

        </pre>
    </div> 
    <div> <!-- 	ES6 - Map  -->
        <p onclick="toggle16()"> ES6 - Map </p>
        <pre id="pre19">

            const mapa1 = new Map([
            ["casa", "house"],
            ["rojo", "red"],
            ["auto", "car"]
          ]);
      
      for(let key of mapa1.keys()) {
        console.log('key:', key)
      } 
      
      for(let value of mapa1.values()) {
        console.log('value:', value)
      } 
      
      for(let [clave, value] of mapa1){
          console.log('c&v:', clave + ' ' + value)
      }

      <hr>

      get()

      const mapa1 = new Map([["casa", "house"],
                             ["rojo", "red"],
                             ["auto", "car"]]);

    const palcastellano = prompt("Ingrese una palabra en castellano:", "");
    console.log(`La traducción de ${palcastellano} es ${mapa1.get(palcastellano)}`)
       
    <hr>

    size

    const mapa1 = new Map([
    ["casa", "house"],
    ["rojo", "red"],
    ["auto", "car"]]);

     mapa1.set("ventana","window");
     console.log(mapa1.size);    // 4

  <hr>

  delete

  const mapa1 = new Map([
  ["casa", "house"],
  ["rojo", "red"],
  ["auto", "car"]]);

    mapa1.delete("casa");
    console.log(mapa1.size);    // 2

    <hr>

    clear()

    const mapa1 = new Map([
    ["casa", "house"],
    ["rojo", "red"],
    ["auto", "car"]]);

        mapa1.clear();
        console.log(mapa1.size);

        <hr>

        forEach()

        const mapa1 = new Map([
        ["casa", "house"],
        ["rojo", "red"],
        ["auto", "car"]
      ]);
  
      console.log("Claves y valores del mapa.")
      mapa1.forEach((valor, clave) => console.log(`${clave}  ${valor}`));
            
        </pre>
        <pre id="pre19a">

            < div id="paises"> < /div>


         addEventListener('DOMContentLoaded', inicio);

         function inicio() {
           const paises = new Map([
             ["Argentina", 45000000],
             ["España", 46000000],
             ["Brasil", 190000000],
             ["Urugual", 3400000]
           ]);
     
           let cadena = '';
           for (let [pais, cantidad] of paises) {
             cadena += `< li>${pais} => ${cantidad}< /li>`;
           }
           document.getElementById("paises").innerHTML = cadena;
         }
            
        </pre>
    </div> 
    <div> <!-- ES6 - Set -->
        <p onclick="toggle17()">ES6 - Set</p>
        <pre id="pre20">

            const conjunto1 = new Set();
            conjunto1.add("C");
            conjunto1.add("Pascal");
            conjunto1.add("PHP");
            conjunto1.add("Python");

            console.log(conjunto1);

        // Set(4) {"C", "Pascal", "PHP", "Python"}

        <hr>
        const conjunto1 = new Set(["C", "Pascal", "PHP", "Python"]);
        console.log(conjunto1);

        // Set(4) {"C", "Pascal", "PHP", "Python"}

        <hr>

        const conjunto1 = new Set();

        for (let x = 0; x < 10; x++){
          conjunto1.add(parseInt(Math.random() * 50) + 1);
          console.log(x)
        }  

        console.log(`La cantidad de números aleatorios distintos son ${conjunto1.size}`)

        if (conjunto1.has(12))
          console.log("Si se generó el número 12")
        else
          console.log("No se generó el número 12")  
            
        </pre>
        <pre id="pre20a">

            delete

            const conjunto1 = new Set(["C", "Pascal", "PHP", "Python"]);
            console.log(conjunto1.size);  // 4
            conjunto1.delete("Pascal");
            console.log(conjunto1.size);  // 3

            <hr>
            const conjunto1 = new Set(["C", "Pascal", "PHP", "Python"]);
            for(let elemento of conjunto1)
              console.log(`${elemento}`);

              <hr>

            forEach    

            const conjunto1 = new Set(["C", "Pascal", "PHP", "Python"]);
            mapa1.forEach((elemento) => console.log(`${elemento}`));

            <hr>

            const feriados = new Set([ "1/1/2020",
                                       "25/5/2020",
                                       "25/12/2020" ]);

              const dia = parseInt(prompt("Ingrese día:", ""));
              const mes = parseInt(prompt("Ingrese mes:", ""));
              const año = parseInt(prompt("Ingrese año:", ""));

              if (feriados.has(`${dia}/${mes}/${año}`))
                console.log("La fecha corresponde a un feriado");
                  else
                console.log("La fecha no corresponde a un feriado");

            </pre>
    </div>   
    <div> <!-- ES6 - WeakMap y WeakSet -->
        <p onclick="toggle18()"> ES6 - WeakMap y WeakSet </p>
        <pre id="pre21">

            They are two objects with similar functionalities to Map and Set but with the ability for the JavaScript garbage collector to remove elements from them when it deems appropriate.

            WeakSet: They can only store data of type object (this is logical because primitive data types cannot have the reference of more than one variable)
            The references to objects in the WeakSet collection are weakly held, this means that if at some point during the execution of the algorithm the object references are lost, then the JavaScript garbage collector frees space from the WeakSet collection.
            
                const set1 = new WeakSet ();
                let user1 = {
                  name: "juan",
                  points: 200
                };
                set1.add (user1);
                console.log (set1.has (user1)); // true
                user1 = null;
                ....
       
        </pre>
        <pre id="pre21a">

            Once the variable 'user1' is removed by setting null, the JavaScript "garbage collector" takes care of removing the item from the set1 object.
            
            WeakMap Only a value of type object can be stored in the map key. JavaScript takes care of removing elements from the map when they no longer have references to the object that acts as a key within the WeakMap.
            
            Annotations
            WeakMap and WeakSet objects do not have the ability to go through their elements through the for of structure, nor can we know the number of elements.
            
            We can delete an element from the collection using the 'delete' method, but it does not have a method to delete all the elements.
            
            The use of these objects makes sense when we know that many objects that act as keys will be eliminated during the execution of the algorithm, otherwise it is convenient to use the Map and Set objects.

        </pre>
    </div>
    <div> <!-- window.addEventListener -->
        <p onclick="toggle19()">window.addEventListener</p>
        <pre id="pre22">


        document.addEventListener(event, function, useCapture) 

          <a href="https://www.w3schools.com/jsref/dom_obj_event.asp" target="_blanck">DOM EVENTS >>></a>

<hr>
        window.onload = load; 

            function handleClick(){
                console.log('a click')
                document.removeEventListener('click', handleClick)
            }

            function load(){
                console.log('window load')
                document.addEventListener('click', handleClick)
            }

            <hr>
            const element = document.querySelector(".class__name");

            element.addEventListener("click", () => {
	            console.log("clicked element");
            });
           
        </pre>
        <pre id="pre22a">

            
            < input type="button" id="boton0" name="boton0" value="0" class="boton">
            < input type="button" id="boton1" name="boton1" value="1" class="boton">
            < input type="button" id="boton2" name="boton2" value="2" class="boton">
            < input type="button" id="boton3" name="boton3" value="3" class="boton">
            < input type="button" id="boton4" name="boton4" value="4" class="boton">
            < input type="button" id="boton5" name="boton5" value="5" class="boton">
            < input type="button" id="boton6" name="boton6" value="6" class="boton">
            < input type="button" id="boton7" name="boton7" value="7" class="boton">
            < input type="button" id="boton8" name="boton8" value="8" class="boton">
            < input type="button" id="boton9" name="boton9" value="9" class="boton">

            < div id="resultado"></ div>

            <hr>

            const inicio = () => {

                for (let x = 0; x <= 9; x++) {
                    
                   let b = document.getElementById('boton' + x)
             
                    b.addEventListener('click', presion, false); 
                }
            
              }
              
              window.addEventListener('DOMContentLoaded', inicio, false);
              
              const presion = evt => {
                  
                  let r = document.getElementById('resultado')
            
                  r.innerHTML = r.innerHTML + evt.target.value + ' ';
            
                  console.log('id:', evt.target.id)
                  console.log('name:', evt.target.name)
                  console.log('value:', evt.target.value)
                  console.log('className:', evt.target.className)
            
              }

              Output

              id: boton1
              name: boton1
              value: 1
              className: boton
    
        </pre>
    </div>
    
    <div> <!-- Global Objects -->
        <p onclick="toggle20()">Global Objects</p>
        <pre id="pre23">


            Global Objects

          <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blanck">Global Objects >>></a>

          <hr>

          let arr = ['a', 'b', 'c'];

          console.log(Object.keys(arr))
          console.log(Object.values(arr))
          console.log(Object.entries(arr))
                     
        </pre>
        <pre id="pre23a">

            
           
            
          
    
        </pre>
    </div> 





    <!--  const monday = [{'name': 'Write a tutorial','duration' : 180},
                          {'name': 'Some web development','duration' : 120}];
 
            const tuesday = [{'name': 'Keep writing that tutorial','duration' : 240},
                           {'name': 'Some more web development','duration' : 180},
                           {'name': 'A whole lot of nothing','duration'  : 240}];
     
            const tasks = [monday, tuesday];
        
            const result = tasks.reduce((acc, current) => acc.concat(current))

                              // Extract the task duration, and convert minutes to hours
                              .map((task) => task.duration / 60)

                              // Filter out any task that took less than two hours
                              .filter((duration) => duration >= 2)

                              // Multiply each tasks' duration by our hourly rate
                              .map((duration) => duration * 25)

                              // Combine the sums into a single dollar amount
                              .reduce((acc, current) => [(+acc) + (+current)])

                              // Convert to a "pretty-printed" dollar amount
                              .map((amount) => '$' + amount.toFixed(2))
                              
                              // Pull out the only element of the array we got from map
                              .reduce((formatted_amount) =>formatted_amount); -->
    
</body>
</html>

