<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS FUNCTIONAL</title>
</head>

<style>

    body{
        font-family: sans-serif;
        background-color: rgb(26, 17, 66);
        color: cornsilk;
        padding-left: 40px;
    }

    pre{
        background-color:rgb(215, 230, 250);
        color:rgba(0, 0, 0, 0.521);
        display: none;
        padding-right: 40px;
        margin-left: 40px;
    }

    p{
        user-select: none; 
        padding-left: 20px; 
    }

    a{
        text-decoration: none;
    }

    .display{
        display: inline-block;
    }

</style>
<script>
    function toggle(){
        document.querySelector("#pre").classList.toggle("display");
        document.querySelector("#pre2").classList.toggle("display");
    }
    
    function toggle2(){
        document.querySelector("#pre4").classList.toggle("display");
        document.querySelector("#pre4a").classList.toggle("display");
        document.querySelector("#pre4b").classList.toggle("display");
    }
    
    function toggle3(){
        document.querySelector("#pre5").classList.toggle("display");
        document.querySelector("#pre5a").classList.toggle("display");
        document.querySelector("#pre6a").classList.toggle("display");
    }
    
       
    function toggle4(){
        document.querySelector("#pre7").classList.toggle("display");
        document.querySelector("#pre7a").classList.toggle("display");
    }

    function toggle5(){
        document.querySelector("#pre8").classList.toggle("display");
        document.querySelector("#pre8a").classList.toggle("display");
        document.querySelector("#pre8b").classList.toggle("display");
    }
    
    function toggle5a(){
        document.querySelector("#pre15aa").classList.toggle("display");
        document.querySelector("#pre15bb").classList.toggle("display");
        document.querySelector("#pre15cc").classList.toggle("display");
    }

    function toggle6(){
        document.querySelector("#pre9").classList.toggle("display");
    }

    function toggle7(){
        document.querySelector("#pre10").classList.toggle("display");
        document.querySelector("#pre10a").classList.toggle("display");
    }

    function toggle8(){
        document.querySelector("#pre11").classList.toggle("display");
    }

    function toggle9(){
        document.querySelector("#pre12").classList.toggle("display");
    }

    function toggle11(){
        document.querySelector("#pre14").classList.toggle("display");
        document.querySelector("#pre14a").classList.toggle("display");
        document.querySelector("#pre14b").classList.toggle("display");
        document.querySelector("#pre14c").classList.toggle("display");
    }

        function toggle12(){
        document.querySelector("#pre15").classList.toggle("display");
        document.querySelector("#pre15a").classList.toggle("display");
    }
    
    function toggle13(){
        document.querySelector("#pre16").classList.toggle("display");
    }

    function toggle14(){
        document.querySelector("#pre17").classList.toggle("display");
        document.querySelector("#pre17a").classList.toggle("display");
        document.querySelector("#pre17b").classList.toggle("display");
    }

    function toggle15(){
        document.querySelector("#pre18").classList.toggle("display");
        document.querySelector("#pre18a").classList.toggle("display");
    }

    function toggle16(){
        document.querySelector("#pre19").classList.toggle("display");
        document.querySelector("#pre19a").classList.toggle("display");
    }

    function toggle17(){
        document.querySelector("#pre20").classList.toggle("display");
        document.querySelector("#pre20a").classList.toggle("display");
    }
     
    function toggle18(){
        document.querySelector("#pre21").classList.toggle("display");
        document.querySelector("#pre21a").classList.toggle("display");
    }

    function toggle19(){
        document.querySelector("#pre22").classList.toggle("display");
        document.querySelector("#pre22a").classList.toggle("display");
    }

    function toggle20(){
        document.querySelector("#pre23").classList.toggle("display");
        document.querySelector("#pre23a").classList.toggle("display");
    }

    function toggle21(){
        document.querySelector("#pre24").classList.toggle("display");
        document.querySelector("#pre24a").classList.toggle("display");
    }

    function toggle22(){
        document.querySelector("#pre25").classList.toggle("display");
        document.querySelector("#pre25a").classList.toggle("display");
    }

    function toggle23(){
        document.querySelector("#pre26").classList.toggle("display");
        document.querySelector("#pre26a").classList.toggle("display");
    }

    function toggle24(){
        document.querySelector("#pre27").classList.toggle("display");
        document.querySelector("#pre27a").classList.toggle("display");
    }

    function toggle25(){
        document.querySelector("#pre28").classList.toggle("display");
        document.querySelector("#pre28a").classList.toggle("display");
    }

    function toggle26(){
        document.querySelector("#pre29").classList.toggle("display");
    }

  


</script>
<body>

    <h1>FUNCTIONAL PROGRAMING</h1>
    <div>  <!-- Introduction -->
        <p onclick="toggle()">Introduction to Functional Programming</p>

        <pre id="pre">

            This is how most of us were taught to program by default (imperatively):

            const numbers = [1, 2, 3, 4];
            let doubled = [];

            for(let i=0; i < numbers.length; i++){
                doubled.push(numbers[i]*2);
            }

            console.log(doubled) 
            
            Output
            
            [2, 4, 6, 8]
        </pre>
        <pre id="pre2">

            This is how it would be done declaratively (using functional programming):
          
            const numbers = [1, 2, 3, 4];
            const doubled = numbers.map(n => n*2);

            console.log(doubled) 
            
            Output
            
            [2, 4, 6, 8];
        </pre>
    </div>  
    <div>  <!-- JavaScript tools -->
        <p onclick="toggle2()">JavaScript tools</p>

        <pre id="pre4">

            - Immutability
            - Use pure functions.
            - Use of higher order functions.
            - Use of currying.
            - Composition of functions.
        </pre>   
        <pre id="pre4a">

            map: Result preserves the shape of the input argument, probably with a different type.

            filter: The result will have the same shape as the input argument, probably shorter.

            reduce: The result can be completely transformed.


            [1, 2, 3].map(n => n+1);      // => [2, 3, 4]
            
            [1, 2, 3].filter(n => n>1);   // => [2, 3]
            
            [1, 2, 3].reduce((acc, n) => acc + n, 0);
            // 0 + 1 => 1
            // 1 + 2 => 3
            // 3 + 3 => 6
            // => 6  
        </pre>
        <pre id="pre4b">

            Higher-order functions are those that take one or more functions as
            an argument or return functions as a result. They interest us 
            because they allow us to reuse the way we execute other functions.

            the map function is defined to receive a function with the 
            signature function (currentValue, index, array)

            const result = ["1", "2", "3"].map((item) => parseInt(item));
            console.log(result);
        </pre> 
    </div>  
    <div>  <!-- map -->
        <p onclick="toggle3()">map</p>
        <pre id="pre5">

            const array1 = [1, 4, 9, 16];

            const map1 = array1.map((element, index, array) => {
                    console.log('index:', index, 'element:', element, 'array1:', array);
            });

            Output

            > "index:" 0 "element:" 1 "array1:" Array [1, 4, 9, 16]
            > "index:" 1 "element:" 4 "array1:" Array [1, 4, 9, 16]
            > "index:" 2 "element:" 9 "array1:" Array [1, 4, 9, 16]
            > "index:" 3 "element:" 16 "array1:" Array [1, 4, 9, 16]
        </pre>

        <pre id="pre5a">

              function returnInt(element) {
                return parseInt(element, 10)
              }
              
              ['1', '2', '3'].map(returnInt); // [1, 2, 3]
              // Actual result is an array of numbers (as expected)
              
              // Same as above, but using the concise arrow function syntax
              ['1', '2', '3'].map( str => parseInt(str) )
              
              // A simpler way to achieve the above, while avoiding the "gotcha":
              ['1', '2', '3'].map(Number)  // [1, 2, 3]
              
              // But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:
              ['1.1', '2.2e2', '3e300'].map(Number)  // [1.1, 220, 3e+300]
              
              // For comparison, if we use parseInt() on the array above:
              ['1.1', '2.2e2', '3e300'].map( str => parseInt(str) ) // [1, 2, 3]
        </pre>
        <pre id="pre6a">
           
            When not to use map()

            Since map builds a new array, using it when you aren't using the returned 
            array is an anti-pattern; use forEach or for...of instead.

            You shouldn't be using map if:

            you're not using the array it returns; and/or
            you're not returning a value from the callback.

            map does not mutate the array on which it is called 
            (although callbackFn, if invoked, may do so).

            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"
             target="_blank">see the docs →</a>
        </pre>    
    </div> 
    <div>  <!-- filter -->
        <p onclick="toggle4()">filter</p>

        <pre id="pre7">

        const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

            const result = words.filter(word => word.length > 6);
            console.log(result);

            output: 
            Array ["exuberant", "destruction", "present"]

            const result2 = words.filter((word, index) => {
                console.log(index, word)
            })

            output:
            > 0 "spray"
            > 1 "limit"
            > 2 "elite"
            > 3 "exuberant"
            > 4 "destruction"
            > 5 "present"
        </pre>
        <pre id="pre7a">

        Filtering out all small values

            const isBigEnough = value => value >= 10;
            let arr = [12, 5, 8, 130, 44]
            let filtered = arr.filter(isBigEnough);

            console.log(filtered)

            Output
            > Array [12, 130, 44]

        let words = ['spray', 'limit', 'exuberant', 'destruction','elite', 'present']

            const modifiedWords = words.filter( (word, index, arr) => {
                 return word[index+2]  //delete the last 2 items
            })
            console.log(modifiedWords)  
            
            Output
            > Array ["spray", "limit", "exuberant", "destruction"]

            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#examples"
            target="_blank">see the docs →</a>
        </pre>
       
    </div>  
    <div> <!-- reduce -->
        <p onclick="toggle5()">reduce</p>
        <pre id="pre8">
 
            const array1 = [1, 2, 3, 4];
            const reducer = (accumulator, currentValue) => accumulator + currentValue;
            
            // 1 + 2 + 3 + 4
            console.log(array1.reduce(reducer));
            output: 10
            
            // 1 + 2 + 3 + 4 + 5
            console.log(array1.reduce(reducer, 5));
            output: 15

            <hr>
            let total = [ 0, 1, 2, 3 ].reduce(
              ( accumulator, currentValue ) => accumulator + currentValue, 1
            )
            console.log(total)
            output: 7
        </pre>
        <pre id="pre8a">

            Sum of values in an object array

            let initialValue = 0
            let sum = [{x: 1}, {x: 2}, {x: 3}].reduce(
                (accumulator, currentValue) => accumulator + currentValue.x, initialValue
            )

            console.log(sum)
            output: 6
        </pre>
        <pre id="pre8b">

            Remove duplicate items in an array (reduce)

            let myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']
            let myArrayWithNoDuplicates = myArray.reduce(function (accumulator, currentValue) {
              if (accumulator.indexOf(currentValue) === -1) {
                accumulator.push(currentValue)
              }
              return accumulator
            }, [])

            console.log(myArrayWithNoDuplicates)

            output: Array ["a", "b", "c", "e", "d"]
            
            <hr>
            or:
            let array = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']
            let arrayWithNoDuplicates = Array.from(new Set(array))
            console.log(arrayWithNoDuplicates)

            output: Array ["a", "b", "c", "e", "d"]
        </pre>
    </div>

    <br/>
    <div> <!-- Loops -->
        <p onclick="toggle5a()">Loops</p>
        <pre id="pre15aa">


        for ([expresion-inicial]; [condicion]; [expresion-final])sentencia

                let arr = [1,2,3,4,5]; 
                
                for(i=0; i < arr.length; i++){
                    console.log(arr[i])
                }

            <hr>

            const array1 = ['a', 'b', 'c'];

            array1.forEach(element => console.log(element));

             output:

                     "a"
                     "b"
                     "c"
        </pre>
        <pre id="pre15bb">

        FOR IN    
          
            const object = {
                name: 'rene',
                age: 22,
                country: 'USA'
            }
              
              for (const property in object) {
                 console.log(`key: ${property}, value: ${object[property]}`)
              }

              > "key: name, value: rene"
              > "key: age, value: 22"
              > "key: country, value: USA"

              // for in is just to objects
        </pre>
        <pre id="pre15cc">

        FOR OF

                let iterable = [10, 20, 30];

                for (let value of iterable) {
                  value += 1;
                  console.log(value);
                }

                Output

                // 11
                // 21
                // 31

                <a href="https://developer.mozilla.org/es/docs/orphaned/Web/JavaScript/Reference/Statements/for...of" target="_blank">see docs →</a>
        </pre>
    </div>  
    <div> <!-- composicion -->
        <p onclick="toggle9()"> Composicion </p>
        <pre id="pre12">
 

          const original = [80, 3, 14, 22, 30];

            let aux = original.filter((value) => value%2 === 0);
            aux = aux.filter((value) => value > 20);
            const result = aux.reduce((accumulator, value) => accumulator + value);

            console.log(result); // 132
       
            <hr>
           
    If we pull ES6 we can apply the chain pattern:

          const original = [80, 3, 14, 22, 30];

            const result = original
                .filter((value) => value%2 === 0)
                .filter((value) => value > 20)
                .reduce((accumulator, value) => accumulator + value);

            console.log(result); // 132 

            <hr>

    Wrap this in functions:

          const original = [80, 3, 14, 22, 30];

            const filterOnlyPairElements = (values) => values.filter((value) => value%2 === 0);
            const filterGreaterThan = (values) => (max) => values.filter((value) => value > max);
            const sumAllValues = (values) => values.reduce((accumulator, value) => accumulator + value);
            
            const result = sumAllValues(
                filterGreaterThan(
                    filterOnlyPairElements(original)
                )(20)
            );
            
            console.log(result); // 132   

            <hr>
            
    This makes this code unreadable, Ramda to the rescue.

        We are going to use Pipe this function allows us to chain functions,
        the output of one serves as input for the other.   
        
          const original = [80, 3, 14, 22, 30];

            const result = R.pipe(
              R.filter((value) => value%2 === 0),
              R.filter((value) => value > 20),  
              R.sum,
            )(original);
        
            console.log(result); // 132

            <hr>
        
    And why do we use things like R.filter and R.sum instead of what ES6 brings for arrays?

          const original = [80, 3, 14, 22, 30];

            const filterOnlyPairElements = (values) => R.filter((value) => value%2 === 0, values);
            const filterGreaterThan = R.curry((max,values) => R.filter((value) => value > max, values));
            const sumAllValues = (values) => R.sum(values);

            const result = R.pipe(
              filterOnlyPairElements,
              filterGreaterThan(20),  
              sumAllValues,
            )(original);

            console.log(result); // 132

        <hr>
        
    we can use the filter and reduce from ES6, being as follows:

        const original = [80, 3, 14, 22, 30];

        const filterOnlyPairElements = (values) => values.filter((value) => value%2 === 0);
        const filterGreaterThan = R.curry((max,values) => values.filter((value) => value > max));
        // Or const filterGreaterThan = (max) => (values) => values.filter((value) => value > max);
        const sumAllValues = (values) => values.reduce((accumulator, value) => accumulator + value);
        
        const result = R.pipe(
          filterOnlyPairElements,
          filterGreaterThan(20),  
          sumAllValues,
        )(original);
        
        console.log(result); // 132

        <hr>

    The pipe function allows us to pass as many callbacks and input parameters as we want such that:

        const result = R.pipe(
            callback1,
            callback2,
            callback3,
            callback4,
            ...
            )(param1, param2, ...);

            <hr>

    But even so, if we don't want to install Ramda or lodash and we want 
    to get the same result applied to the previous array, we could do something like:

        const original = [80, 3, 14, 22, 30];

        const filterOnlyPairElements = (values) => values.filter((value) => value%2 === 0);
        const filterGreaterThan = (max) => (values) => values.filter((value) => value > max);
        const sumAllValues = (values) => values.reduce((accumulator, value) => accumulator + value);
        
        const pipe = (...callbacks) => (array) => (
          callbacks.reduce((previous, callback) => (
            callback(previous)
          ), array)
        );
        
        const result = pipe(
          filterOnlyPairElements,
          filterGreaterThan(20),
          sumAllValues,
        )(original);
        
        console.log(result); // 132
        </pre>
    </div>
    <div> <!-- closures -->
        <p onclick="toggle7()">Closures</p>
        <pre id="pre10">
          
            
            function error(str) {
                console.log(`%c Error: ${str} `, 'background: red; color: white;');
              }
              
            function warning(str) {
                console.log(`%c Warning: ${str} `, 'background: orange; color: white;');
              }
              
            function success(str) {
                console.log(`%c success: ${str} `, 'background: green; color: white;');
              }

              error('error text')
              warning('warning text')
              success('success text')  
        </pre>
        <pre id="pre10a">

            closure:

            function messages(typeM, styles) {
                return function message(str) {
                  console.log(`%c ${typeM}: ${str} `, styles);
                }
              }
              
              const error = messages('Error', 'background: red;');
              const warning = messages('Warning', 'background: orange;');
              const success = messages('Success', 'background: green;');
              
              error('error text')
              warning('warning text')
              success('success text')
        </pre>
    </div>  
    <div> <!-- currying -->
        <p onclick="toggle8()">Currying</p>
        <pre id="pre11">
 
            
            const sum = (a, b) => {
                return a + b
            }

            sum(2, 2)
             
            <hr>

            const sumCurrying = (a) => {
                return (b) => {
                return a + b
              }
            }

            const res = sumCurrying(1)(2)
            console.log(res)

            <hr>

            const sumCurryingS = (a) => (b) => (c) => a + b + c;

            sumCurryingS(1)(2)(3)

            <hr>

            const sumCurrying= (a) => (b) => a + b;

            const increment10 = sumCurrying(10)

            const res = increment10(20)
            
            console.log(res)

            Output
            30

        </pre>
    </div>  
    <div> <!-- Generator -->
        <p onclick="toggle11()">Generator </p>
        <pre id="pre14">

        convert the code of a function into iterable code

            function* iterable(){

                yield 'hello 1';
                console.log('hello from log')
                yield 'hello 2';
                yield 'hello 3';
                console.log('hello again from log')
                yield 'hello 4';
                yield 'hello 5';
            }
             
            let iterador = iterable()

                console.log(iterador.next());
                console.log(iterador.next());
                console.log(iterador.next());
                console.log(iterador.next());
                console.log(iterador.next());

                console.log(iterador.next());   //undefined done:true (true. is the end )
                console.log(iterador.return(1)) // {value: 1, done: true}

                Output

                {value: "hello 1", done: false}
                hello from log
                {value: "hello 2", done: false}
                {value: "hello 3", done: false}
                hello again from log
                {value: "hello 4", done: false}
                {value: "hello 5", done: false}
                {value: undefined, done: true}
                {value: 1, done: true}
        </pre>
        <pre id="pre14a">
            
            function* iterable(){

                yield 'hello 1';
                console.log('hello from log')
                yield 'hello 2';
                yield 'hello 3';
                console.log('hello again from log')
                yield 'hello 4';
                yield 'hello 5';
            }
             
            let iterator = iterable()

            for(let y of iterator){
                console.log(y)
            }
        </pre>
        <pre id="pre14b">

            function* iterable(){

                yield 'hello 1';
                console.log('hello from log')
                yield 'hello 2';
                yield 'hello 3';
                console.log('hello again from log')
                yield 'hello 4';
                yield 'hello 5';
            }

            let arr = [...iterable()]
            console.log(arr)

            Output

            hello from log
            hello again from log
            ["hello 1", "hello 2", "hello 3", "hello 4", "hello 5"]
        </pre>
        <pre id="pre14c">

            function* gen() {
                while(true) {
                  try {
                     yield 42;
                  } catch(e) {
                    console.log('Error caught!');
                  }
                }
              }
              
              var g = gen();
              g.next();
              // { value: 42, done: false }
              g.throw(new Error('Something went wrong'));
              // "Error caught!"
              // { value: 42, done: false }
              
        </pre>
    </div>   
    <div> <!--  -->
        <p onclick="toggle12()">Decorator</p>
        <pre id="pre15">

            let arr = [5, 1, 8];
            let isTiny = (el) => el < 2;
            console.log(arr.find(isTiny));
            
            Output
            1
        </pre>
        <pre id="pre15a">

            Returns the found value in the array, 
            if an element in the array satisfies 
            the provided testing function or undefined if not found. 
            Similar to findIndex(), but it returns the item instead of the index.

            const array = [0,1,,,,5,6];

            array.find(function(value, index) {
                  console.log('Visited index ' + index + ' with value ' + value);
            });
        </pre>
    </div> 
    <div> <!-- IFEE -->
        <p onclick="toggle13()">IFEE</p>
        <pre id="pre16">

            An IIFE (Immediately Invoked Function Expression)
            This prevents accessing variables within the IIFE idiom as well as polluting the global scope.

            (function () {
                statements
              })();
        </pre>
    </div> 
    <div> <!-- Array.from() -->
        <p onclick="toggle14()">Array.from()</p>
        <pre id="pre17">
          
            console.log(Array.from('foo')); 
            
            output:
            Array ["f", "o", "o"]

            console.log(Array.from([1, 2, 3], x => x + 1)); 
            
            output:
            Array [2, 4, 6]

            let arr = 'hello'
            Array.from(arr, (element, index) => { 
                 console.log('index:', index, element + ' -') 
            })
            
            index: 0 h -
            index: 1 e -
            index: 2 l -
            index: 3 l -
            index: 4 o -
        </pre>
        <pre id="pre17a">

            Array from a Map
            const map = new Map([[1, 2], [2, 4], [4, 8]]);
            Array.from(map);
            // [[1, 2], [2, 4], [4, 8]]
            
            const mapper = new Map([['1', 'a'], ['2', 'b']]);
            Array.from(mapper.values());
            // ['a', 'b'];
            
            Array.from(mapper.keys());
            // ['1', '2'];

            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from"
            target="_blank">see the docs →</a>
        </pre>
        <pre id="pre17b">

            Sequence generator (range)

            // Sequence generator function (commonly referred to as "range", e.g. Clojure, PHP etc)
            const range = (start, stop, step) => Array.from({
                 length: (stop - start) / step + 1
            }, (_, i) => start + (i * step));

            // Generate numbers range 0..4
            range(0, 4, 1);
            // [0, 1, 2, 3, 4]

            // Generate numbers range 1..10 with step of 2
            range(1, 10, 2);
            // [1, 3, 5, 7, 9]

            // Generate the alphabet using Array.from making use of it being ordered as a sequence
            range('A'.charCodeAt(0), 'Z'.charCodeAt(0), 1).map(x => String.fromCharCode(x));
            // ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", 
            "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

        </pre>
    </div>   

    <div> <!-- REST PARAMETERS-->
        <p onclick="toggle15()">REST PARAMETERS</p>
        <pre id="pre18">

            RECEIVE UNLIMITED PARAMETERS IN A FUNCTION

            function separarConComa1() {
                let resultado = ''
                for (let i = 0; i < arguments.length; i++) {
                  if (resultado !== '') {
                    resultado += ' + ';
                  }
                  resultado += arguments[i];
                }
                return resultado;
              }
              separarConComa1('MEME', 'MEME', 'MEME')

              NOTE: YOU CAN NOT USE ARGUMENTS(object) IN A AROW FUNCTION
        </pre>
        <pre id="pre18a">


            const separador = (...strings) => {
                let res = '';
                    for(i=0; i < strings.length; i++){
                        if(res !== ' '){
                            res += ' + '
                        }
                    res += strings[i]
                }
                return res
            }

            separador('ff','ee','dd')

            <hr>

            const separarCon = (separator, ...strings) => 
                strings.reduce((resultado, str) => {

                if (resultado !== '') {
                  resultado += separator
                };
              
                return resultado + str;
            }, '');
              
            console.log(separarCon(' + ', 'Pablo', 'Laura', 'Juan'));

        </pre>
    </div>  
    <div> <!--  one or many items values based on a condition i create -->
        <p onclick="toggle16()">one or many items values based on a condition i create</p>
        <pre id="pre19">

            let arr = [5, 1, 8];
            let filtered = arr.filter(el => el > 4);
            console.log(filtered)

            Output
            [5, 8]
        </pre>
        <pre id="pre19a">

            Creates a new array with all of the elements 
            of this array for which the provided 
            filtering function returns true.
        </pre>
    </div> 
    <div> <!-- one or many items whether or not every item satisfies a condition -->
        <p onclick="toggle17()">one or many items whether or not every item satisfies a condition</p>
        <pre id="pre20">

            let arr = [5, 1, 8];
            let isSmall = (el) => el < 10;
            console.log(arr.every(isSmall));
            
            Output
            true
        </pre>
        <pre id="pre20a">

            Returns true if every element in this array
            satisfies the provided testing function.
        </pre>
    </div>   
    <div> <!-- one or many items whether or not at least one item satisfies a condition -->
        <p onclick="toggle18()">one or many items whether or not at least one item satisfies a condition</p>
        <pre id="pre21">

            let arr = [5, 1, 8];
            let biggerThan4 = (el) => el > 4;
            console.log(arr.some(biggerThan4));

            Output
            true
        </pre>
        <pre id="pre21a">

            Returns true if at least one element in this array 
            satisfies the provided testing function.
        </pre>
    </div>

    <br>

    <div> <!-- walk over items, execuiting a function i will create for each element -->
        <p onclick="toggle19()">walk over items, execuiting a function i will create for each element</p>
        <pre id="pre22">

            let arr = [5, 1, 8];
            arr.forEach((element) => {
              console.log(element)
            });
            
            Output

            5
            1
            8
        </pre>
        <pre id="pre22a">

            The forEach() method executes a provided function once for each array element.

            const array1 = ['a', 'b', 'c'];

            array1.forEach((element, index,  array) => console.log(index, element, array));
             
            Output

            > 0 "a" Array ["a", "b", "c"]
            > 1 "b" Array ["a", "b", "c"]
            > 2 "c" Array ["a", "b", "c"]
        </pre>
    </div> 
    
    <div> <!-- walk over items, creating new array from each element with a function i crerate -->
        <p onclick="toggle20()">walk over items, creating new array from each element with a function i crerate</p>
        <pre id="pre23">

            let arr = [5, 1, 8];
            let map = arr.map(x => x + 1);
            console.log(map);

            Output

            [6, 2, 9]
        </pre>
        <pre id="pre23a">

            Creates a new array with the results of calling a 
            provided function on every element in this array.

            let string = Array.from('hello')

            console.log(string)  
            console.log(Array.from([1, 2, 3], x => x * 3 ));

            Output
 
            > Array ["h", "e", "l", "l", "o"]
            > Array [3, 6, 9]
        </pre>
    </div> 
    <div> <!--  creating an iterator object    -->
        <p onclick="toggle21()">creating an iterator object</p>
        <pre id="pre24">

            let arr = [5, 1, 8];
            let iterator = arr.entries();
            console.log(iterator.next().value);
            console.log(iterator.next().value);

            Output
            [0, 5]
            // the 0 is the index,
            // the 5 is the first number

            [1, 1]
        </pre>
        <pre id="pre24a">

            Returns a new Array Iterator object that contains the key/value 
            pairs for each index in the array. There are a lot of uses for iterators, 
            as well as other methods used with it in conjuction, like values and keys
        </pre>
    </div>  
   
    <br>

    <div> <!-- return a string, join all Elements of the array into a string -->
        <p onclick="toggle22()">return a string, join all Elements of the array into a string</p>
        <pre id="pre25">

            let arr = [5, 1, 8];
            console.log(arr.join(' '));

            Output

            5 1 8

            let arr = [5, 1, 8];
            console.log(arr.join('-'));

            Output

            5-1-8
        </pre>
        <pre id="pre25a">

            Returns a string representing the array and its elements.

            let arr = [5, 1, 8];
            console.log(arr.toString());
            
            Output
            "5,1,8" 
        </pre>
    </div>
    <div> <!-- order an array, reverse the order of the array -->
        <p onclick="toggle23()"> order an array, reverse the order of the array</p>
        <pre id="pre26">

            let arr = [5, 1, 8];
            arr.reverse();
            console.log(arr);
            
            Output
            [8, 1, 5]
        </pre>
        <pre id="pre26a">

            Reverses the order of the elements of an array in place
          — the first becomes the last, and the last becomes the first.

          const points = [40, 100, 1, 5, 25, 10];

          points.sort(function(a, b){return b - a});
          points.reverse()
          console.log(points)
        </pre>
    </div> 
    <div> <!-- sort the items of the array -->
        <p onclick="toggle24()"> sort the items of the array</p>
        <pre id="pre27">

            let arr = [5, 1, 8];
            arr.reverse();
            console.log(arr);
            
            Output 
            [8, 1, 5]
        </pre>
        <pre id="pre27a">

            Sorts the elements of an array in place and returns the array.

            Important note: If compareFunction is not supplied, 
            elements are sorted by converting them to strings and
            comparing strings in Unicode code point order. 

            For example, "Banana" comes before "cherry".
            In a numeric sort, 9 comes before 80, but because numbers 
            are converted to strings, "80" comes before "9" in Unicode order. 

            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"
             target="_blank">see the docs →</a>
        </pre>
    </div>  
    <div> <!-- Fills all the elements of an array  -->
        <p onclick="toggle25()"> Fills all the elements of an array </p>
        <pre id="pre28">

            const array1 = [1, 2, 3, 4];

            // fill with 0 from position 2 until position 4
            console.log(array1.fill(0, 2, 4));
            // expected output: [1, 2, 0, 0]
            
            // fill with 5 from position 1
            console.log(array1.fill(5, 1));
            // expected output: [1, 5, 5, 5]
            
            console.log(array1.fill(6));
            // expected output: [6, 6, 6, 6]
        </pre>
        <pre id="pre28a">

            Sorts the elements of an array in place and returns the array.

            Important note: If compareFunction is not supplied, 
            elements are sorted by converting them to strings and
            comparing strings in Unicode code point order. 

            For example, "Banana" comes before "cherry".
            In a numeric sort, 9 comes before 80, but because numbers 
            are converted to strings, "80" comes before "9" in Unicode order. 

            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"
             target="_blank">see the docs →</a>
        </pre>
    </div> 
    <div> <!-- Copies a sequence of array elements within the array. -->
        <p onclick="toggle26()"> Copies a sequence of array elements within the array.</p>
        <pre id="pre29">
             
            You can specify either just the ending element 
            (where begin will default to zero)
            or both the beginning and the end, comma-separated.

            [1, 2, 3, 4, 5].copyWithin(0, 3, 4)
            // [4, 2, 3, 4, 5]
        </pre>
    </div>   

    <br>
    
</body>
</html>
